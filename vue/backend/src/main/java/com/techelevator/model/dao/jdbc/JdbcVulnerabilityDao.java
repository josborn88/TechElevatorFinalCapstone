package com.techelevator.model.dao.jdbc;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Component;

import com.techelevator.model.Vulnerability;
import com.techelevator.model.dao.VulnerabilityDao;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.rowset.SqlRowSet;

@Component
public class JdbcVulnerabilityDao implements VulnerabilityDao {

	// SQL Insert Statements
	private static final String SQL_INSERT_REPORT_VULNERABILITY = "WITH ins AS ( INSERT INTO risks ( name , summary , risk_reporter) "
			+ "VALUES ( ? , ? , ?) RETURNING risk_id), " + "ins2 AS ( INSERT INTO images (risk_id , image_file) VALUES "
			+ "( ( SELECT risk_id FROM ins ), ? ) RETURNING risk_id ) "
			+ "INSERT INTO locations (risk_id, location_name , client_name , street_address) VALUES "
			+ " ( ( SELECT risk_id FROM ins ), ? , ? , ? ) ";

	// SQL Select Statements
	private static final String SQL_SELECT_VIEW_ALL_VULNERABILITY = "SELECT risks.risk_id, risks.name, "
			+ "risks.risk_reporter, risks.summary, risks.priority, risks.is_repaired, risks.repair_confirmed_by, "
			+ "risks.datefiled , risks.is_duplicate , risks.recommended_repair_date , "
			+ "images.image_id, images.image_file, locations.location_name, locations.location_id, "
			+ "locations.client_name, locations.street_address, locations.risk_location FROM risks "
			+ "JOIN images ON risks.risk_id = images.risk_id JOIN locations ON risks.risk_id = locations.risk_id";

	// SQL Update Statements
	private static final String SQL_UPDATE_PRIORITY_STATUS = "UPDATE risks SET priority = ? WHERE risk_id = ?";
	private static final String SQL_UPDATE_REPAIRED_STATUS = "UPDATE risks SET is_repaired = NOT is_repaired, repair_confirmed_by = ? WHERE risk_id = ?";
	private static final String SQL_UPDATE_DUPLICATE_STATUS = "UPDATE risks SET is_duplicate = NOT is_duplicate WHERE risk_id = ?";
	private static final String SQL_UPDATE_REPAIR_DATE = "UPDATE risks SET recommended_repair_date = ? WHERE risk_id = ?";

	// Constants
	private static final String VULNERABILITY_ID = "risk_id";
	private static final String VULNERABILITY_NAME = "name";
	private static final String VULNERABILITY_REPORTER = "risk_reporter";
	private static final String VULNERABILITY_SUMMARY = "summary";
	private static final String VULNERABILITY_PRIORITY = "priority";
	private static final String VULNERABILITY_REPAIR_STATUS = "is_repaired";
	private static final String CONFIRMATION_USER = "repair_confirmed_by";
	private static final String IMAGE_ID = "image_id";
	private static final String IMAGE_NAME = "image_file";
	private static final String LOCATION_NAME = "location_name";
	private static final String LOCATION_ID = "location_id";
	private static final String LOCATION_CLIENT_NAME = "client_name";
	private static final String LOCATION_STREET_ADDRESS = "street_address";
	private static final String LOCATION_OF_THE_RISK = "risk_location";
	private static final String VULNERABILITY_FILE_DATE = "datefiled";
	private static final String DUPLICATE_VULNERABILITY = "is_duplicate";
	private static final String VULNERABILITY_RECOMMENDED_REPAIR_DATE = "recommended_repair_date";

	private JdbcTemplate db;

	@Autowired
	public JdbcVulnerabilityDao(DataSource dataSource) {
		this.db = new JdbcTemplate(dataSource);
	}

	// Reports and adds a new Vulnerability to the Database
	@Override
	public void reportVulnerability(Report report) {
		String insertSql = SQL_INSERT_REPORT_VULNERABILITY;

		db.update(insertSql, report.getName(), report.getSummary(), report.getRiskReporter(), report.getImageName(),
				report.getLocationName(), report.getClientName(), report.getLocationAddress());
	}

	// List that Views all information of all Reports -- Only SELECT SQL Code
	@Override
	public List<Vulnerability> viewAllVulnerabilityReports() {

		List<Vulnerability> allVulnerabilityReports = new ArrayList<Vulnerability>();

		String selectReportsSql = SQL_SELECT_VIEW_ALL_VULNERABILITY;

		SqlRowSet rows = db.queryForRowSet(selectReportsSql);

		while (rows.next()) {
			Vulnerability report = mapRowsToVulnerability(rows);
			allVulnerabilityReports.add(report);
		}

		return allVulnerabilityReports;
	}

	// Updates Priority of a Report
	@Override
	public void updateReportPriority(Vulnerability report, String priority) {

		String updateSql = SQL_UPDATE_PRIORITY_STATUS;

		db.update(updateSql, priority, report.getId());

	}

	// Updates repair Status
	@Override
	public void updateIsRepaired(Vulnerability report) {

		String updateSql = SQL_UPDATE_REPAIRED_STATUS;

		db.update(updateSql, report.getRepairConfirmedBy(), report.getId());
	}

	// Updates Duplicate Status
	@Override
	public void updateIsDuplicate(Vulnerability report) {

		String updateSql = SQL_UPDATE_DUPLICATE_STATUS;

		db.update(updateSql, report.getId());
	}

	// Update Repair Date
	@Override
	public void updateRepairDate(Vulnerability report, String repairDate) {
		String updateSql = SQL_UPDATE_REPAIR_DATE;

		db.update(updateSql, repairDate, report.getId());
	}

	// Map Rows to Vulnerability
	private Vulnerability mapRowsToVulnerability(SqlRowSet row) {
		Vulnerability vulnerability = new Vulnerability();
		Location location = mapRowToLocation(row);
		Image image = mapRowsToImage(row);

		vulnerability.setId(row.getLong(VULNERABILITY_ID));
		vulnerability.setRepaired(row.getBoolean(VULNERABILITY_REPAIR_STATUS)); // Change to Boolean
		vulnerability.setRepairConfirmedBy(row.getString(CONFIRMATION_USER));
		vulnerability.setName(row.getString(VULNERABILITY_NAME));
		vulnerability.setSummary(row.getString(VULNERABILITY_SUMMARY));
		vulnerability.setPriority(row.getString(VULNERABILITY_PRIORITY));
		vulnerability.setRiskReporter(row.getString(VULNERABILITY_REPORTER));
		vulnerability.setDateFiled(row.getDate(VULNERABILITY_FILE_DATE));
		vulnerability.setDuplicate(row.getBoolean(DUPLICATE_VULNERABILITY));
		vulnerability.setRepairDate(row.getString(VULNERABILITY_RECOMMENDED_REPAIR_DATE));
		vulnerability.setLocation(location);
		vulnerability.setImage(image);

		return vulnerability;
	}

	// Map Rows to Location --
	private Location mapRowToLocation(SqlRowSet row) {
		Location location = new Location();

		location.setAddress(row.getString(LOCATION_STREET_ADDRESS));
		location.setClientName(row.getString(LOCATION_CLIENT_NAME));
		location.setLocation_id(row.getLong(LOCATION_ID));
		location.setLocationName(row.getString(LOCATION_NAME));
		location.setRiskLocation(row.getString(LOCATION_OF_THE_RISK));

		return location;
	}

	// Map Rows to Image --
	private Image mapRowsToImage(SqlRowSet row) {
		Image image = new Image();

		image.setImageId(row.getLong(IMAGE_ID));
		image.setImageName(row.getString(IMAGE_NAME));

		return image;
	}
}
